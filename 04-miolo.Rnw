<<echo=FALSE>>=
suppressMessages(library(knitr))
suppressMessages(library(ggplot2))

opts_chunk$set(echo = FALSE, fig.height = 4)
options(digits = 2)

formata_data <- function(data) {
  format(as.POSIXct(data), "%d/%m/%Y")
}

knit_hooks$set(inline = function(x) {
  if (is.numeric(x)) {
    num = ifelse(x == round(x), sprintf("%d", x), sprintf("%.2f", x))
    prettyNum(num, decimal.mark = ",", big.mark = ".")
  }
})

setwd("data")

legislatures = c(50, 51, 52, 53, 54)
votes = list()
votes_metadata = list()

for (legislature in legislatures) {
  votes[[legislature]] = read.csv(paste(legislature, ".csv", sep=""),
                                  header = TRUE, check.names = FALSE)
  votes_metadata[[legislature]] = read.csv(paste(legislature, "-votacoes.csv", sep=""),
                                           header = TRUE, check.names = FALSE)
}
@

\chapter{Miolo da sua dissertação}\label{cap:miolo}

Nessa parte pretendo falar sobre a ferramenta desenvolvida, mostrar sua arquitetura e como cada parte funciona e pode ser modificada.

\section{Coleta dos dados}

A Câmara dos Deputados disponibiliza em seu site na
web\footnote{\url{http://www2.camara.leg.br/transparencia/dados-abertos}} uma
\gls{API} para acesso a diversos dados. Para extrair os resultados das
votações, usamos os métodos
\emph{ListarProposicoesVotadasEmPlenario}\footnote{\url{http://www2.camara.leg.br/transparencia/dados-abertos/dados-abertos-legislativo/webservices/proposicoes-1/ProposicoesVotadasEmPlenario}}
que a partir de um ano nos retorna a lista de proposições votadas; e o
\emph{ObterVotacaoProposicao}\footnote{\url{http://www2.camara.leg.br/transparencia/dados-abertos/dados-abertos-legislativo/webservices/proposicoes-1/obtervotacaoproposicao}}
que a partir do tipo, número e ano de uma proposição retorna os resultados das
votações ocorridas.  

Os dados são retornados no formato \gls{XML}. De posse deles, desenvolvemos um
programa em
Python\footnote{\url{https://github.com/vitorbaptista/codigo-mestrado}} para
transformá-los e importá-los em um banco de dados
SQLite\footnote{\url{https://www.sqlite.org/}}. A partir desse banco, geramos
dois arquivos por legislatura: um com os dados dos parlamentares e seus votos
(tabela \ref{table:votes}) e outro com os detalhes das votações (tabela
\ref{table:votes-metadata}).

Os nomes dos partidos foram normalizados para evitar que consideremos fusões ou
mudanças de nomes de partidos como um novo partido. Seguimos o padrão adotado
pelo \gls{CEBRAP}, onde mudanças de nome são identificados pela primeira e
última sigla (ex.: PJ se torna PRN que se torna PJC, então temos PJ>PTC) e
fusões são identificados pelo maior partido na data da fusão e o novo nome
(ex.: PL e PRONA se tornam PL>PR) \cite{Freitas2008}. A lista completa está no
apêndice \ref{apendice:lista-partidos}.

\begin{table}
\centering
<<>>=
kable(head(votes[[54]][, c(1:9)]))
@
\caption{Dados com detalhes dos parlamentares e seus respectivos votos. Não
mostramos todos os votos por limitações de espaço.}
\label{table:votes}
\end{table}

\begin{landscape}
\begin{table}
\centering
<<>>=
max_str_length = 20
table_data = head(votes_metadata[[54]], 10)
table_data$resumo = paste0(strtrim(table_data$resumo, max_str_length), "...")
table_data$obj_votacao = paste0(strtrim(table_data$obj_votacao, max_str_length), "...")
kable(table_data)
@
\caption{Dados com detalhes sobre cada votação. Os campos ``resumo'' e
``obj\_votacao'' foram limitados a \Sexpr{max_str_length} caracteres por
questões de formatação da página.}
\label{table:votes-metadata}
\end{table}
\end{landscape}

% \begin{listing}[ht]
% \begin{minted}{xml}
% <proposicoes>
%   <proposicao>
%     <codProposicao>19319</codProposicao>
%     <nomeProposicao>PL 3232/1992</nomeProposicao>
%     <dataVotacao>10/06/2014</dataVotacao>
%   </proposicao>
%   <proposicao>
%     <codProposicao>43617</codProposicao>
%     <nomeProposicao>PLP 275/2001</nomeProposicao>
%     <dataVotacao>22/04/2014</dataVotacao>
%   </proposicao>
%   <!-- Continua... -->
% </proposicoes>
% \end{minted}
% \caption{Resultado da API \emph{ListarProposicoesVotadasEmPlenario} usando o ano 2014 como parâmetro}
% \end{listing}

Restringimos a analisar da 50\textordfeminine{} até a 54\textordfeminine{}
legislatura, que compreende um período de 20 anos, entre o início do primeiro
governo de Fernando Henrique Cardoso em 1995 até o final do primeiro governo de
Dilma Rousseff em 2015. Esse recorte foi feito pois é quando, de acordo com
\cite{Freitas2008}, termina a fase de acomodação dos parlamentares as regras
definidas pela Constituição de 1988.

\begin{table}
\centering
<<>>=
num_deputados = simplify2array(lapply(votes[legislatures], nrow))
num_votacoes = simplify2array(lapply(votes[legislatures], ncol)) - 4
num_votos = simplify2array(lapply(votes[legislatures], function (v) {
  just_votes = v[, -c(1:4)]
  sum(just_votes == 0 | just_votes == 1, na.rm = TRUE)
}))
data = data.frame(legislature = legislatures,
                  num_deputados = num_deputados,
                  num_votacoes = num_votacoes,
                  num_votos = num_votos)

kable(data,
      row.names = FALSE,
      col.names = c("Legislatura", "Deputados Federais", "Votações", "Votos"))
@
\caption{Número de deputados federais e votações por legislatura}
\label{table:estatisticas-legislaturas}
\end{table}

Na tabela \ref{table:estatisticas-legislaturas}, mostramos o número de
deputados federais e votações por legislatura. Consideramos deputados federais
todos parlamentares que participaram de alguma votação na Câmara dos Deputados
no período, por isso o número é maior do que o número de cadeiras. Por
legislatura, temos em média \Sexpr{mean(num_deputados)} deputados e \Sexpr{mean(num_votacoes)}
votações com \Sexpr{mean(num_votos) / mean(num_votacoes)} votos cada.

\section{Componentes}

Mostrar em linhas gerais como é organizada a ferramenta, indo de um nível de abstração mais alto (como o usuário vê a ferramenta) até uma arquitetura técnica.


% ALEXANDRE: Apesar de eu não ser muito fã acho importante apresentar algum tipo de diagrama de componentes nesta seção, para permitir uma visualização da arquitetura da solução.


\subsection{Extração dos dados}

Falar sobre as fontes de dados (câmara dos deputados, banco de dados legislativos do Cebrap, etc.), a forma de extração, passos de limpeza, banco de dados, frequência de atualização, se é pull ou push, e como disponibilizamos esses dados para as outras etapas. Ao término dessa seção, o leitor deverá entender nosso processo de data wrangling e saber como ele próprio pode, se quiser, baixar os dados ao final dessa etapa e fazer suas próprias análises. Talvez tenha problema com isso, pois o pessoal da CEBRAP pode não permitir a redistribuição de seus dados.


% ALEXANDRE: É interessante destacar que disponibilizar estes dados em um formato mais "amigável" também é uma contribuição do seu trabalho.

\subsection{Análise}

Aqui falarei sobre os algoritmos usados e as métricas escolhidas (coesão parlamentar, número de destaques, etc.). Também é bom frisar que a arquitetura permite adicionar novos algoritmos, talvez até de uma forma reativa. Por exemplo, considerando que a acusação que o PP trancou a pauta para pressionar o Lula a nomear uma pessoa na Petrobrás, poderíamos criar um algoritmo que detectasse trancamentos de pauta por um partido qualquer, para no futuro descobrirmos movimentações parecidas.

\subsection{Notificações/Relatórios}

Falar sobre como os usuários consomem esses dados. Minha ideia atual é gerar um relatório semanal/mensal/quando-aparecer-algo-interessante e enviá-lo por email pra quem se cadastrar. Nesse caso, devo mostrar exemplos desse relatório.


(Alexandre) Seria legal considerar também a criação de uma conta que twitaria periódicamente os relatórios.


\section{Considerações Finais}

Desenvolvi uma ferramenta que extrai dados de diversas fontes, os consolida, analisa e gera relatórios para os usuários. Cada parte pode ser modificada e expandida, e os dados (e algoritmos) podem ser usados por outras pessoas. Daqui falta validar que os algoritmos na parte de análise geram algo interessante.
